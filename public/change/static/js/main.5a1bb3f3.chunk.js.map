{"version":3,"sources":["change.js","App.js","serviceWorker.js","index.js"],"names":["Change","coins","value","matrix","row","Array","fill","i","length","push","Infinity","this","createBaseMatrix","coin","r","Math","min","coinArray","target","Error","coinMatrix","solveMatrix","expectedNumberOfCoins","rtnArr","j","unshift","App","React","useState","setCoins","setTarget","solution","setSolution","paperStyle","margin","padding","style","textAlign","Grid","container","justify","direction","item","Paper","elevation","TextField","id","label","onChange","event","fullWidth","helperText","Button","onClick","coinsArray","replace","split","index","Number","myTarget","change","mySolution","calculate","sort","a","b","toString","error","message","variant","color","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console"],"mappings":"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","file":"static/js/main.5a1bb3f3.chunk.js","sourcesContent":["\n// createBaseMatrix and solveMatrix were taken from:\n// https://en.wikipedia.org/wiki/Change-making_problem\n\n// for the calucate function I used this video for inspiration:\n// https://www.youtube.com/watch?v=Y0ZqKpToTic\n\n\nexport class Change {\n\n  // creates a (coins + 1) * (value + 1) matrix\n  createBaseMatrix(coins, value) {\n\n    let matrix = []\n\n    // our row is the length of value + 1\n    let row = new Array(value + 1).fill(0, 0)\n\n    // Our cols will be the the number of coins + 1\n    for (let i = 0; i < coins.length + 1; i++) {\n      matrix.push([...row])\n    }\n\n    // we set every element in the first row,\n    // except for the first as infinity\n    for (let i = 1; i < value + 1; i++) {\n\n      matrix[0][i] = Infinity\n    }\n\n    return matrix\n  }\n\n  // Using classic dynamic programming by finding the combinations\n  // of all smaller values that would sum to the current threshold.\n  solveMatrix(coins, value) {\n\n    let matrix = this.createBaseMatrix(coins, value)\n\n    for (let coin = 1; coin < coins.length + 1; coin++) {\n\n      for (let r = 1; r < value + 1; r++) {\n\n        // just use the coin coins[coin - 1]\n        if (coins[coin - 1] === r) {\n          matrix[coin][r] = 1\n        }\n        // coins[coin - 1] cannot be included.\n        // Use the previous solution for making r,\n        // excluding coins[coin - 1].\n        else if (coins[coin - 1] > r) {\n          matrix[coin][r] = matrix[coin - 1][r]\n        }\n        // coins[c - 1] can be used.\n        // Decide which one of the following solutions is the best\n        // 1. Using the previous solution for making r (without using coins[c - 1]).\n        // 2. Using the previous solution for making r - coins[c - 1] (without\n        //      using coins[c - 1]) plus this 1 extra coin.\n        else {\n          matrix[coin][r] = Math.min(matrix[coin - 1][r], 1 + matrix[coin][r - coins[coin - 1]])\n        }\n      }\n    }\n\n    return matrix\n  }\n\n  calculate(coinArray = [], target) {\n\n    // check or negitive target\n    if (target < 0) {\n      throw new Error(\"Negative totals are not allowed.\")\n    }\n\n    // set the expected number of coins\n    const coinMatrix = this.solveMatrix(coinArray, target)\n    const expectedNumberOfCoins = coinMatrix[coinArray.length][target]\n\n    // check to see if the target is possible\n    // given the selected coins\n    if (expectedNumberOfCoins === Infinity) {\n      throw new Error(`The total ${target} cannot be represented in the given currency.`)\n    }\n\n    let rtnArr = []\n\n    // set matrix location\n    // this is the element that we are evaluating\n    // in the coinMatrix\n    let [i, j] = [coinArray.length, target]\n\n    // while not on a zero value of the coin matrix\n    while (coinMatrix[i][j] > 0) {\n\n      // if the target is bigger than the coin\n      if (j >= coinArray[i - 1]) {\n\n        // if the element above the location is less\n        // than the element to the left + 1\n        // move the location up a row\n        // else move the location left and add that value to the rtnArr\n        if (coinMatrix[i - 1][j] < 1 + coinMatrix[i][j - coinArray[i - 1]]) {\n\n          // go up\n          i = i - 1\n\n        } else {\n\n          // go left\n          j = j - coinArray[i - 1]\n\n          // add this value at the current location to the return array\n          rtnArr.unshift(coinArray[i - 1])\n        }\n        // if the target is less than the coin\n      } else {\n\n        // move the location up\n        i = i - 1\n      }\n\n    } // end of while loop\n\n    return rtnArr\n\n  } // end of calcuate\n} // end of Change class\n\n\n\n/*\nSolved using recursion with solveMatrix to check if solution is optimal\n\n    // check or negitive target\n    if(target < 0){\n      throw new Error(\"Negative totals are not allowed.\")\n    }\n\n    // set the expected number of coins\n    const expectedNumberOfCoins = this.solveMatrix(coinArray, target)[coinArray.length][target]\n\n    // check to see if the target is possible\n    // given the selected coins\n    if(expectedNumberOfCoins == Infinity){\n      throw new Error(`The total ${target} cannot be represented in the given currency.`)\n    }\n\n    // reverse our coin array so we start with\n    // the largest coin\n    let reverseCoin = coinArray.reverse()\n\n    // set our return array\n    let rtnArr = []\n\n    // set another target variable so we\n    // don't changes the orginal target\n    let currentTarget = target\n\n    // count represets the index value\n    // of the coin Array\n    let count = 0\n\n    // While our target is not met\n    while(currentTarget != 0){\n\n      // looking at our fist coin\n      // which should be the largest\n      let coin = reverseCoin[count]\n\n      // if the coin is undefined\n      // this happens when we go through each coin\n      // without reaching zero\n      if(coin === undefined){\n\n        // Our \"stuck\" coin will be the first\n        // coin in our return array\n        // we will remove it from our return array\n        // and add it back to the target value\n        let stuckCoin = rtnArr.shift()\n        currentTarget += stuckCoin\n\n        // we will start our loop back at\n        // the coin after our stuck coin\n        count = reverseCoin.indexOf(stuckCoin) + 1\n        coin = reverseCoin[count]\n      }\n\n      // if our coin brings our target below zero\n      // we move on to the next smaller coin\n      // we do not update the target\n      if(currentTarget - coin < 0){\n\n        count++\n      }\n      // if our coin brings our target to 0\n      // then we add the coin to our return array\n      // and update the target to escape the loop\n      else if (currentTarget - coin == 0){\n\n        rtnArr.unshift(coin)\n        currentTarget -= coin\n\n      }\n      // if our coin leaves some target left over\n      // we subtract the coin from our target and\n      // add it to our return array\n      else if (currentTarget - coin > 0) {\n\n        currentTarget -= coin\n        rtnArr.unshift(coin)\n      }\n\n    } // end of while\n\n    // if we find a valid set of coins, we want\n    // to make sure that it is the smallest set\n    // if it is not, we run calculate again with\n    // the largest coin removed\n    if(rtnArr.length > expectedNumberOfCoins){\n\n      //TODO\n      // instead of popping of the largest coin,\n      // we should remove the all coins greater than\n      // and equal to the largest coin in the return array\n\n      coinArray.reverse().pop()\n\n      let newArr = coinArray\n\n      rtnArr = this.calculate(newArr, target)\n\n    }\n\n    return rtnArr\n\n*/\n","import React from 'react';\nimport './App.css';\nimport Paper from '@material-ui/core/Paper'\nimport Grid from '@material-ui/core/Grid'\nimport TextField from '@material-ui/core/TextField'\nimport { Button } from '@material-ui/core';\nimport { Change } from './change'\n\nfunction App() {\n\n  const [coins, setCoins] = React.useState('1,5,10,25,50')\n  const [target, setTarget] = React.useState('123')\n  const [solution, setSolution] = React.useState('Your change will be here!')\n\n  const paperStyle = {\n    margin: 16,\n    padding: 16\n  }\n\n  const onClickHandler = () => {\n\n    // change our coins string into an array\n    // remove whitespace and split at commas\n    let coinsArray = coins.replace(/\\s/g, '').split(',')\n\n    // change the string to numbers\n    for (let index = 0; index < coinsArray.length; index++) {\n      coinsArray[index] = Number(coinsArray[index])\n    }\n\n    // change the target to a number\n    let myTarget = Number(target)\n\n    // create a change object\n    const change = new Change()\n\n\n    try {\n      // get our solution\n      let mySolution = change.calculate(coinsArray, myTarget)\n\n      // sort our solution\n      mySolution = mySolution.sort((a, b) => a - b)\n\n      // set our state\n      setSolution(mySolution.toString())\n    } catch (error) {\n      //if an error set state to our error message\n      setSolution(error.message)\n    }\n\n  }\n\n  return (\n    <div style={{ padding: '0 25% 0 25%', textAlign: 'center' }}>\n      <Grid container justify='center' direction='column' >\n        <Grid item >\n          <Paper elevation={3} style={paperStyle}>\n            <div>\n              <h1>Change Maker</h1>\n            </div>\n          </Paper>\n        </Grid>\n        <Grid item>\n          <Paper elevation={3} style={paperStyle}>\n            <div style={{ padding: '0 25% 0 25%' }}>\n              <TextField id=\"coins\"\n                label=\"Coins\"\n                value={coins}\n                onChange={(event) => { setCoins(event.target.value) }}\n                fullWidth\n                helperText='seperate coin values by commas'\n              />\n\n              <br />\n              <TextField id=\"target\"\n                label=\"Your target value\"\n                fullWidth\n                value={target}\n                onChange={(event) => { setTarget(event.target.value) }}\n                helperText='its got to be a number'\n              />\n            </div>\n            <div>\n              <Button onClick={onClickHandler} variant='contained' color='primary'>Find the Change!</Button>\n            </div>\n          </Paper>\n        </Grid>\n        <Grid item >\n          <Paper elevation={3} style={paperStyle}>\n            <div>\n              <h2>Your Change is...</h2>\n            </div>\n            <div>\n              {solution}\n            </div>\n          </Paper>\n        </Grid>\n      </Grid>\n\n\n    </div>\n  )\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}